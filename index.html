<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™¶æ™¶å¤§å†’é™©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#FFD700',
                        secondary: '#C0C0C0',
                        danger: '#FF4500',
                        success: '#32CD32',
                        dark: '#1A1A2E',
                        light: '#F5F5F5'
                    },
                    fontFamily: {
                        pixel: ['Press Start 2P', 'monospace']
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'bounce-slow': 'bounce 2s infinite',
                        'spin-slow': 'spin 3s linear infinite',
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .pixel-borders {
                box-shadow: 
                    -4px 0 0 0 #000,
                    4px 0 0 0 #000,
                    0 -4px 0 0 #000,
                    0 4px 0 0 #000;
            }
            .pixel-borders-light {
                box-shadow: 
                    -2px 0 0 0 #fff,
                    2px 0 0 0 #fff,
                    0 -2px 0 0 #fff,
                    0 2px 0 0 #fff;
            }
            .text-shadow {
                text-shadow: 2px 2px 0 #000;
            }
            .text-shadow-light {
                text-shadow: 2px 2px 0 #fff;
            }
            .pixel-scaling {
                image-rendering: pixelated;
                image-rendering: crisp-edges;
            }
        }
    </style>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', monospace;
            background-color: #1A1A2E;
            color: #F5F5F5;
            overflow: hidden;
            touch-action: none;
            margin: 0;
            padding: 0;
        }
        
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
            max-width: 100vw;
            max-height: 100vh;
            margin: 0 auto;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .ui-overlay > * {
            pointer-events: auto;
        }
        
        .start-screen, .game-over-screen, .level-up-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 46, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        
        .button {
            background-color: #FFD700;
            color: #1A1A2E;
            padding: 10px 20px;
            margin: 10px;
            border: none;
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 
                -4px 0 0 0 #000,
                4px 0 0 0 #000,
                0 -4px 0 0 #000,
                0 4px 0 0 #000;
        }
        
        .button:hover {
            transform: translateY(-2px);
        }
        
        .button:active {
            transform: translateY(2px);
            box-shadow: 
                -2px 0 0 0 #000,
                2px 0 0 0 #000,
                0 -2px 0 0 #000,
                0 2px 0 0 #000;
        }
        
        .stats {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .shield-container {
            display: flex;
            gap: 5px;
        }
        
        .shield-icon {
            width: 24px;
            height: 24px;
        }
        
        .weapon-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        
        .weapon-icon {
            width: 32px;
            height: 32px;
            border: 2px solid #FFD700;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .level-progress {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid #FFD700;
        }
        
        .level-progress-bar {
            height: 100%;
            background-color: #FFD700;
            width: 0%;
            transition: width 0.3s;
        }
        
        .enemy-spawn-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid #FF4500;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.2);
            }
        }
        
        .floating-text {
            position: absolute;
            font-size: 12px;
            color: #FFD700;
            animation: float-up 1s forwards;
            pointer-events: none;
        }
        
        @keyframes float-up {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px);
            }
        }
        
        .level-up-option {
            background-color: rgba(26, 26, 46, 0.8);
            border: 2px solid #FFD700;
            padding: 10px;
            margin: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .level-up-option:hover {
            background-color: rgba(255, 215, 0, 0.2);
            transform: translateY(-2px);
        }
        
        .level-up-option .option-icon {
            width: 32px;
            height: 32px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* è™šæ‹Ÿæ‘‡æ†æ ·å¼ */
        .joystick-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            z-index: 15;
            display: none; /* é»˜è®¤éšè—ï¼Œåœ¨ç§»åŠ¨è®¾å¤‡ä¸Šæ˜¾ç¤º */
        }
        
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid #FFD700;
        }
        
        .joystick-thumb {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(255, 215, 0, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid #000;
            touch-action: none;
        }
        
        /* ç§»åŠ¨è®¾å¤‡æ ·å¼ */
        @media (max-width: 768px) {
            .joystick-container {
                display: block;
            }
            
            .stats, .weapon-container, .level-progress {
                position: absolute;
            }
            
            .stats {
                top: 10px;
                left: 10px;
                font-size: 12px;
            }
            
            .weapon-container {
                bottom: 150px;
                left: 10px;
            }
            
            .level-progress {
                bottom: 10px;
                right: 10px;
                width: 150px;
                height: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- è™šæ‹Ÿæ‘‡æ† -->
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-base" id="joystickBase"></div>
            <div class="joystick-thumb" id="joystickThumb"></div>
        </div>
        
        <div class="ui-overlay">
            <div class="stats">
                <div class="stat-item">
                    <span>ç­‰çº§:</span>
                    <span id="playerLevel">1</span>
                </div>
                <div class="stat-item">
                    <span>æŠ¤ç›¾:</span>
                    <div class="shield-container" id="shieldContainer">
                        <!-- Shield icons will be added here -->
                    </div>
                </div>
            </div>
            
            <div class="weapon-container" id="weaponContainer">
                <!-- Weapon icons will be added here -->
            </div>
            
            <div class="level-progress">
                <div class="level-progress-bar" id="levelProgressBar"></div>
            </div>
        </div>
        
        <div class="start-screen" id="startScreen">
            <h1 class="text-4xl mb-8 text-shadow">åƒç´ å¹¸å­˜è€…</h1>
            <h2 class="text-2xl mb-4 text-shadow">å¤ªé˜³å†’é™©</h2>
            <div class="mb-8">
                <span style="font-size: 80px;">â˜€ï¸</span>
            </div>
            <button class="button" id="startButton">å¼€å§‹æ¸¸æˆ</button>
            <div class="mt-8 text-sm max-w-md text-center">
                <p class="mb-2">æ§åˆ¶æ–¹å‘: WASD æˆ– æ–¹å‘é”®</p>
                <p class="mb-2">æ”¶é›†å¤ªé˜³è¿›åŒ–: æ—¥ â†’ æ˜Œ â†’ æ™¶</p>
                <p class="mb-2">æ”¶é›†æ˜Ÿæ˜Ÿè·å¾—ç»éªŒå’Œæ­¦å™¨</p>
                <p>å‡»è´¥UFOå’Œåç¾¿ï¼Œç”Ÿå­˜ä¸‹å»!</p>
            </div>
        </div>
        
        <div class="game-over-screen hidden" id="gameOverScreen">
            <h1 class="text-4xl mb-8 text-shadow">æ¸¸æˆç»“æŸ</h1>
            <div class="mb-4">
                <span>ä½ çš„åˆ†æ•°:</span>
                <span id="finalScore">0</span>
            </div>
            <div class="mb-4">
                <span>ç”Ÿå­˜æ—¶é—´:</span>
                <span id="survivalTime">0</span>
            </div>
            <button class="button" id="restartButton">é‡æ–°å¼€å§‹</button>
        </div>
        
        <div class="level-up-screen hidden" id="levelUpScreen">
            <h2 class="text-2xl mb-4 text-shadow">å‡çº§!</h2>
            <div class="mb-4">é€‰æ‹©ä¸€ä¸ªå‡çº§é€‰é¡¹:</div>
            <div class="level-up-options" id="levelUpOptions">
                <!-- Level up options will be added here -->
            </div>
        </div>
    </div>

    <script>
        // æ¸¸æˆå¸¸é‡
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const PLAYER_SPEED = 3;
        const ENEMY_BASE_SPEED = 1;
        const PROJECTILE_SPEED = 5;
        const SUN_SPAWN_RATE = 2000; // æ¯«ç§’
        const STAR_SPAWN_RATE = 3000; // æ¯«ç§’
        const ENEMY_SPAWN_RATE = 1500; // æ¯«ç§’
        const LEVEL_UP_EXPERIENCE = 100;
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            running: false,
            player: {
                x: CANVAS_WIDTH / 2,
                y: CANVAS_HEIGHT / 2,
                width: 40,
                height: 40,
                level: 1, // 1: æ—¥, 2: æ˜Œ, 3: æ™¶
                shields: 0,
                maxShields: 3,
                experience: 0,
                nextLevelExp: LEVEL_UP_EXPERIENCE,
                weapons: [],
                lastAttackTime: 0,
                attackCooldown: 500
            },
            projectiles: [],
            enemies: [],
            collectibles: [],
            keys: {
                up: false,
                down: false,
                left: false,
                right: false
            },
            score: 0,
            survivalTime: 0,
            lastEnemySpawn: 0,
            lastSunSpawn: 0,
            lastStarSpawn: 0,
            enemySpawnRate: ENEMY_SPAWN_RATE,
            enemySpawnCount: 0,
            difficultyMultiplier: 1
        };
        
        // æ¸¸æˆèµ„æº - ä½¿ç”¨æ–‡å­—ä»£æ›¿å›¾ç‰‡
        const gameFont = 'Press Start 2P, monospace';
        const textElements = {
            player: {
                1: 'æ—¥', // æ—¥
                2: 'æ˜Œ', // æ˜Œ
                3: 'æ™¶'  // æ™¶
            },
            sun: 'æ—¥',
            star: 'è¾°',
            shield: 'ğŸ›¡ï¸',
            enemies: {
                ufo: 'ğŸ›¸',
                archer: 'ğŸ¹',
                drop: 'ğŸ’§'
            },
            weapons: {
                fireball: 'ğŸ”¥',
                lightning: 'âš¡',
                star: 'â­',
                laser: 'ğŸ’«',
                missile: 'ğŸš€',
                bomb: 'ğŸ’£'
            }
        };

        // æ¸¸æˆå…ƒç´ 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const levelUpScreen = document.getElementById('levelUpScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const levelUpOptions = document.getElementById('levelUpOptions');
        const playerLevelElement = document.getElementById('playerLevel');
        const shieldContainer = document.getElementById('shieldContainer');
        const weaponContainer = document.getElementById('weaponContainer');
        const levelProgressBar = document.getElementById('levelProgressBar');
        const finalScoreElement = document.getElementById('finalScore');
        const survivalTimeElement = document.getElementById('survivalTime');
        
        // æ­¦å™¨å®šä¹‰
        const weaponTypes = {
            fireball: {
                name: "ç«çƒ",
                damage: 20,
                range: 200,
                cooldown: 500,
                projectileSpeed: 5,
                spread: 0,
                pierce: false,
                description: "å‘å°„ç«çƒï¼Œé€ æˆä¸­ç­‰ä¼¤å®³"
            },
            lightning: {
                name: "é—ªç”µ",
                damage: 15,
                range: 300,
                cooldown: 300,
                projectileSpeed: 8,
                spread: 0.3,
                pierce: true,
                description: "å‘å°„é—ªç”µï¼Œå¯ç©¿é€æ•Œäºº"
            },
            star: {
                name: "æ˜Ÿæ˜Ÿ",
                damage: 10,
                range: 150,
                cooldown: 200,
                projectileSpeed: 4,
                spread: 0.6,
                pierce: false,
                description: "å‘å°„æ˜Ÿæ˜Ÿï¼ŒèŒƒå›´æ”»å‡»"
            },
            laser: {
                name: "æ¿€å…‰",
                damage: 30,
                range: 400,
                cooldown: 1000,
                projectileSpeed: 10,
                spread: 0,
                pierce: true,
                description: "å‘å°„æ¿€å…‰ï¼Œé«˜ä¼¤å®³ç©¿é€"
            },
            missile: {
                name: "å¯¼å¼¹",
                damage: 50,
                range: 250,
                cooldown: 2000,
                projectileSpeed: 6,
                spread: 0.1,
                pierce: false,
                description: "å‘å°„å¯¼å¼¹ï¼Œè¿½è¸ªæ•Œäººå¹¶çˆ†ç‚¸"
            },
            bomb: {
                name: "ç‚¸å¼¹",
                damage: 100,
                range: 300,
                cooldown: 3000,
                projectileSpeed: 3,
                spread: 0.2,
                pierce: false,
                description: "æŠ•æ·ç‚¸å¼¹ï¼Œå¤§èŒƒå›´çˆ†ç‚¸ä¼¤å®³"
            }
        };
        
        // æ•Œäººç±»å‹
        const enemyTypes = {
            ufo: {
                name: "UFO",
                health: 30,
                speed: 1.5,
                damage: 10,
                width: 40,
                height: 40,
                attackRange: 100,
                attackCooldown: 2000,
                points: 10,
                isBoss: false
            },
            archer: {
                name: "åç¾¿",
                health: 20,
                speed: 1,
                damage: 15,
                width: 40,
                height: 40,
                attackRange: 200,
                attackCooldown: 3000,
                points: 15,
                isBoss: false
            },
            drop: {
                name: "æ°´æ»´",
                health: 40,
                speed: 2,
                damage: 20,
                width: 32,
                height: 32,
                attackRange: 50,
                attackCooldown: 1500,
                points: 20,
                isBoss: true
            }
        };
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            gameState = {
                running: false,
                player: {
                    x: CANVAS_WIDTH / 2,
                    y: CANVAS_HEIGHT / 2,
                    width: 40,
                    height: 40,
                    level: 1,
                    shields: 0,
                    maxShields: 3,
                    experience: 0,
                    nextLevelExp: LEVEL_UP_EXPERIENCE,
                    weapons: [],
                    lastAttackTime: 0,
                    attackCooldown: 500
                },
                projectiles: [],
                enemies: [],
                collectibles: [],
                keys: {
                    up: false,
                    down: false,
                    left: false,
                    right: false
                },
                score: 0,
                survivalTime: 0,
                lastEnemySpawn: 0,
                lastSunSpawn: 0,
                lastStarSpawn: 0,
                enemySpawnRate: ENEMY_SPAWN_RATE,
                enemySpawnCount: 0,
                difficultyMultiplier: 1,
                enemiesPerSpawn: 1,
                enemiesPerSpawn: 1
            };
            
            updateUI();
        }
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            initGame();
            gameState.running = true;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            levelUpScreen.classList.add('hidden');
            
            // æ·»åŠ ä¸€ä¸ªåˆå§‹æ­¦å™¨
            addWeapon('fireball');
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            lastTime = performance.now();
            gameLoop();
        }
        
        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameState.running = false;
            levelUpScreen.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            gameOverScreen.style.zIndex = '30';
            finalScoreElement.textContent = gameState.score;
            survivalTimeElement.textContent = formatTime(gameState.survivalTime);
        }
        
        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        // æ›´æ–°UI
        function updateUI() {
            playerLevelElement.textContent = gameState.player.level;
            
            // æ›´æ–°æŠ¤ç›¾æ˜¾ç¤º
            shieldContainer.innerHTML = '';
            for (let i = 0; i < gameState.player.shields; i++) {
                const shieldIcon = document.createElement('div');
                shieldIcon.textContent = textElements.shield;
                shieldIcon.className = 'shield-icon text-2xl text-cyan-400';
                shieldContainer.appendChild(shieldIcon);
            }
            
            // æ›´æ–°æ­¦å™¨æ˜¾ç¤º
            weaponContainer.innerHTML = '';
            gameState.player.weapons.forEach(weapon => {
                const weaponIcon = document.createElement('div');
                weaponIcon.textContent = textElements.weapons[weapon.type];
                weaponIcon.className = 'weapon-icon text-xl text-white';
                weaponIcon.title = weaponTypes[weapon.type].name;
                weaponContainer.appendChild(weaponIcon);
            });
            
            // æ›´æ–°ç»éªŒæ¡
            const progress = (gameState.player.experience / gameState.player.nextLevelExp) * 100;
            levelProgressBar.style.width = `${progress}%`;
        }
        
        // æ˜¾ç¤ºå‡çº§é€‰é¡¹
        function showLevelUpOptions() {
            levelUpScreen.classList.remove('hidden');
            levelUpOptions.innerHTML = '';
            
            // ç”Ÿæˆå‡çº§é€‰é¡¹
            const options = [];
            
            // æ·»åŠ æ­¦å™¨é€‰é¡¹
            const availableWeapons = Object.keys(weaponTypes).filter(type => 
                !gameState.player.weapons.some(w => w.type === type)
            );
            
            if (availableWeapons.length > 0) {
                const randomWeapon = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                options.push({
                    type: 'weapon',
                    weaponType: randomWeapon,
                    name: `æ–°æ­¦å™¨: ${weaponTypes[randomWeapon].name}`,
                    description: weaponTypes[randomWeapon].description,
                    icon: textElements.weapons[randomWeapon]
                });
            }
            
            // æ·»åŠ æŠ¤ç›¾é€‰é¡¹
            if (gameState.player.shields < gameState.player.maxShields) {
                options.push({
                    type: 'shield',
                    name: 'æŠ¤ç›¾ +1',
                    description: 'å¢åŠ ä¸€ä¸ªæŠ¤ç›¾',
                    icon: textElements.shield
                });
            }
            
            // æ·»åŠ å‡çº§ç°æœ‰æ­¦å™¨é€‰é¡¹
            if (gameState.player.weapons.length > 0) {
                const randomWeapon = gameState.player.weapons[Math.floor(Math.random() * gameState.player.weapons.length)];
                options.push({
                    type: 'upgrade',
                    weaponType: randomWeapon.type,
                    name: `å‡çº§: ${weaponTypes[randomWeapon.type].name}`,
                    description: 'æå‡æ­¦å™¨ä¼¤å®³å’Œé€Ÿåº¦',
                    icon: textElements.weapons[randomWeapon.type]
                });
            }
            
            // æ·»åŠ æœ€å¤§æŠ¤ç›¾é€‰é¡¹
            options.push({
                type: 'maxShield',
                name: 'æœ€å¤§æŠ¤ç›¾ +1',
                description: 'å¢åŠ æœ€å¤§æŠ¤ç›¾å®¹é‡',
                icon: textElements.shield
            });
            
            // ç¡®ä¿æœ‰3ä¸ªé€‰é¡¹
            while (options.length < 3) {
                options.push({
                    type: 'maxShield',
                    name: 'æœ€å¤§æŠ¤ç›¾ +1',
                    description: 'å¢åŠ æœ€å¤§æŠ¤ç›¾å®¹é‡',
                    icon: textElements.shield
                });
            }
            
            // éšæœºé€‰æ‹©3ä¸ªé€‰é¡¹
            const selectedOptions = options.slice(0, 3);
            
            // åˆ›å»ºé€‰é¡¹å…ƒç´ 
            selectedOptions.forEach(option => {
                const optionElement = document.createElement('div');
                optionElement.className = 'level-up-option';
                optionElement.innerHTML = `
                    <div class="option-icon">${option.icon}</div>
                    <div>
                        <div>${option.name}</div>
                        <div class="text-xs opacity-70">${option.description}</div>
                    </div>
                `;
                
                optionElement.addEventListener('click', () => {
                    applyLevelUpOption(option);
                    levelUpScreen.classList.add('hidden');
                    gameState.running = true;
                    lastTime = performance.now();
                    requestAnimationFrame(gameLoop);
                });
                
                levelUpOptions.appendChild(optionElement);
            });
        }
        
        // åº”ç”¨å‡çº§é€‰é¡¹
        function applyLevelUpOption(option) {
            switch (option.type) {
                case 'weapon':
                    addWeapon(option.weaponType);
                    break;
                case 'shield':
                    gameState.player.shields = Math.min(gameState.player.shields + 1, gameState.player.maxShields);
                    break;
                case 'upgrade':
                    upgradeWeapon(option.weaponType);
                    break;
                case 'maxShield':
                    gameState.player.maxShields += 1;
                    gameState.player.shields = Math.min(gameState.player.shields + 1, gameState.player.maxShields);
                    break;
            }
            
            updateUI();
        }
        
        // æ·»åŠ æ­¦å™¨
        function addWeapon(weaponType) {
            gameState.player.weapons.push({
                type: weaponType,
                level: 1,
                lastFired: 0
            });
        }
        
        // å‡çº§æ­¦å™¨
        function upgradeWeapon(weaponType) {
            const weapon = gameState.player.weapons.find(w => w.type === weaponType);
            if (weapon) {
                weapon.level += 1;
            }
        }
        
        // ç”Ÿæˆéšæœºä½ç½®ï¼ˆåœ¨å±å¹•è¾¹ç¼˜ï¼‰
        function getRandomEdgePosition() {
            const side = Math.floor(Math.random() * 4); // 0: ä¸Š, 1: å³, 2: ä¸‹, 3: å·¦
            let x, y;
            
            switch (side) {
                case 0: // ä¸Š
                    x = Math.random() * CANVAS_WIDTH;
                    y = -50;
                    break;
                case 1: // å³
                    x = CANVAS_WIDTH + 50;
                    y = Math.random() * CANVAS_HEIGHT;
                    break;
                case 2: // ä¸‹
                    x = Math.random() * CANVAS_WIDTH;
                    y = CANVAS_HEIGHT + 50;
                    break;
                case 3: // å·¦
                    x = -50;
                    y = Math.random() * CANVAS_HEIGHT;
                    break;
            }
            
            return { x, y };
        }
        
        // ç”Ÿæˆéšæœºä½ç½®ï¼ˆåœ¨å±å¹•å†…ï¼‰
        function getRandomPosition() {
            return {
                x: Math.random() * (CANVAS_WIDTH - 100) + 50,
                y: Math.random() * (CANVAS_HEIGHT - 100) + 50
            };
        }
        
        // ç”Ÿæˆæ•Œäºº
        function spawnEnemy() {
            let enemyType;
            // æ¯10ä¸ªæ•Œäººæœ‰1ä¸ªæ¦‚ç‡ç”Ÿæˆæ°´æ»´
            if (Math.random() < 0.1 || gameState.enemySpawnCount % 10 === 0) {
                enemyType = 'drop';
            } else {
                const regularEnemies = ['ufo', 'archer'];
                enemyType = regularEnemies[Math.floor(Math.random() * regularEnemies.length)];
            }

            const typeData = enemyTypes[enemyType];
            const position = getRandomEdgePosition();
            
            // æ ¹æ®éš¾åº¦è°ƒæ•´æ•Œäººå±æ€§
            const healthMultiplier = 1 + (gameState.difficultyMultiplier - 1) * 0.5;
            const speedMultiplier = 1 + (gameState.difficultyMultiplier - 1) * 0.2;
            
            const enemy = {
                type: enemyType,
                x: position.x,
                y: position.y,
                width: typeData.width,
                height: typeData.height,
                health: Math.floor(typeData.health * healthMultiplier),
                maxHealth: Math.floor(typeData.health * healthMultiplier),
                speed: typeData.speed * speedMultiplier,
                damage: typeData.damage,
                attackRange: typeData.attackRange,
                lastAttack: 0,
                attackCooldown: typeData.attackCooldown,
                points: typeData.points,
                isBoss: typeData.isBoss || false,
                angle: Math.random() * Math.PI * 2,
                angleSpeed: 0.02
            };
            
            gameState.enemies.push(enemy);
            gameState.enemySpawnCount++;

            // æ°´æ»´æ•Œäººç”Ÿæˆæ—¶æ˜¾ç¤ºè­¦å‘Š
            if (enemy.isBoss) {
                showEnemySpawnIndicator(enemy);
            }

            // æ¯10ä¸ªæ•Œäººå¢åŠ éš¾åº¦
            if (gameState.enemySpawnCount % 10 === 0) {
                gameState.difficultyMultiplier += 0.1;
                gameState.enemySpawnRate = Math.max(ENEMY_SPAWN_RATE * (1 - (gameState.difficultyMultiplier - 1) * 0.1), 500);
                
                // æ¯20ä¸ªæ•Œäººå¢åŠ ä¸€æ¬¡ç”Ÿæˆçš„æ•Œäººæ•°é‡
                if (gameState.enemySpawnCount % 20 === 0) {
                    gameState.enemiesPerSpawn = Math.min(gameState.enemiesPerSpawn + 1, 5); // æœ€å¤šä¸€æ¬¡ç”Ÿæˆ5ä¸ªæ•Œäºº
                }
            }
        }
        
        // æ˜¾ç¤ºæ•Œäººç”ŸæˆæŒ‡ç¤ºå™¨ï¼ˆç®€å•å®ç°ï¼‰
        function showEnemySpawnIndicator(enemy) {
            // åœ¨æ•Œäººç”Ÿæˆä½ç½®æ˜¾ç¤ºä¸€ä¸ªçº¢è‰²è„‰å†²åœˆï¼ˆé€šè¿‡ä¸´æ—¶DOMå…ƒç´ ï¼‰
            const indicator = document.createElement('div');
            indicator.className = 'enemy-spawn-indicator';
            indicator.style.left = enemy.x + 'px';
            indicator.style.top = enemy.y + 'px';
            document.querySelector('.game-container').appendChild(indicator);
            setTimeout(() => indicator.remove(), 1000);
        }
        
        // ç”Ÿæˆå¤ªé˜³
        function spawnSun() {
            const position = getRandomPosition();
            gameState.collectibles.push({
                type: 'sun',
                x: position.x,
                y: position.y,
                width: 30,
                height: 30
            });
        }
        
        // ç”Ÿæˆæ˜Ÿæ˜Ÿ
        function spawnStar() {
            const position = getRandomPosition();
            gameState.collectibles.push({
                type: 'star',
                x: position.x,
                y: position.y,
                width: 30,
                height: 30,
                experience: 20 + Math.floor(Math.random() * 30) // 20-50ç»éªŒå€¼
            });
        }
        
        // ç”ŸæˆæŠ¤ç›¾
        function spawnShield() {
            const position = getRandomPosition();
            gameState.collectibles.push({
                type: 'shield',
                x: position.x,
                y: position.y,
                width: 30,
                height: 30
            });
        }
        
        // å‘å°„æŠ•å°„ç‰©
        function fireProjectile(weapon, targetX, targetY) {
            const weaponData = weaponTypes[weapon.type];
            const player = gameState.player;
            
            // è®¡ç®—æ–¹å‘
            let angle = Math.atan2(targetY - player.y, targetX - player.x);
            
            // æ·»åŠ æ•£å¸ƒ
            if (weaponData.spread > 0) {
                angle += (Math.random() - 0.5) * weaponData.spread;
            }
            
            // è®¡ç®—é€Ÿåº¦
            const speedX = Math.cos(angle) * weaponData.projectileSpeed;
            const speedY = Math.sin(angle) * weaponData.projectileSpeed;
            
            // åŸºç¡€ä¼¤å®³
            let damage = weaponData.damage;
            
            // æ ¹æ®æ­¦å™¨ç­‰çº§å¢åŠ ä¼¤å®³
            if (weapon.level > 1) {
                damage = Math.floor(damage * (1 + (weapon.level - 1) * 0.5));
            }
            
            // åˆ›å»ºæŠ•å°„ç‰©
            gameState.projectiles.push({
                type: weapon.type,
                x: player.x,
                y: player.y,
                width: 20,
                height: 20,
                speedX: speedX,
                speedY: speedY,
                damage: damage,
                range: weaponData.range,
                pierce: weaponData.pierce,
                distance: 0,
                isEnemy: false // æ ‡è®°æ˜¯å¦ä¸ºæ•Œæ–¹æŠ•å°„ç‰©
            });
            
            // æ›´æ–°æœ€åå‘å°„æ—¶é—´
            weapon.lastFired = Date.now();
        }
        
        // è‡ªåŠ¨æ”»å‡»æœ€è¿‘çš„æ•Œäºº
        function autoAttack() {
            const player = gameState.player;
            const currentTime = Date.now();
            
            if (player.weapons.length === 0) return;
            
            // æ‰¾åˆ°æœ€è¿‘çš„æ•Œäºº
            let closestEnemy = null;
            let closestDistance = Infinity;
            
            for (const enemy of gameState.enemies) {
                const distance = Math.sqrt(
                    Math.pow(enemy.x - player.x, 2) + 
                    Math.pow(enemy.y - player.y, 2)
                );
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestEnemy = enemy;
                }
            }
            
            if (closestEnemy) {
                for (const weapon of player.weapons) {
                    const weaponData = weaponTypes[weapon.type];
                    
                    if (currentTime - weapon.lastFired >= weaponData.cooldown) {
                        if (closestDistance <= weaponData.range) {
                            fireProjectile(weapon, closestEnemy.x, closestEnemy.y);
                        }
                    }
                }
            }
        }
        
        // æ£€æŸ¥ç¢°æ’
        function checkCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }
        
        // æ˜¾ç¤ºæµ®åŠ¨æ–‡æœ¬
        function showFloatingText(text, x, y, color = '#FFD700') {
            const floatingText = document.createElement('div');
            floatingText.className = 'floating-text';
            floatingText.textContent = text;
            floatingText.style.left = `${x}px`;
            floatingText.style.top = `${y}px`;
            floatingText.style.color = color;
            
            document.querySelector('.game-container').appendChild(floatingText);
            
            setTimeout(() => {
                floatingText.remove();
            }, 1000);
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update(deltaTime) {
            const player = gameState.player;
            
            gameState.survivalTime += deltaTime;
            
            // å¤„ç†ç©å®¶ç§»åŠ¨
            if (gameState.keys.up) player.y -= PLAYER_SPEED;
            if (gameState.keys.down) player.y += PLAYER_SPEED;
            if (gameState.keys.left) player.x -= PLAYER_SPEED;
            if (gameState.keys.right) player.x += PLAYER_SPEED;
            
            player.x = Math.max(player.width / 2, Math.min(CANVAS_WIDTH - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(CANVAS_HEIGHT - player.height / 2, player.y));
            
            autoAttack();
            
            // æ›´æ–°æŠ•å°„ç‰©
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const projectile = gameState.projectiles[i];
                
                projectile.x += projectile.speedX;
                projectile.y += projectile.speedY;
                
                projectile.distance += Math.sqrt(
                    Math.pow(projectile.speedX, 2) + 
                    Math.pow(projectile.speedY, 2)
                );
                
                if (projectile.distance > projectile.range) {
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
                
                if (
                    projectile.x < -50 || 
                    projectile.x > CANVAS_WIDTH + 50 || 
                    projectile.y < -50 || 
                    projectile.y > CANVAS_HEIGHT + 50
                ) {
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
                
                // æ£€æŸ¥ä¸ç©å®¶çš„ç¢°æ’ï¼ˆæ•Œæ–¹æŠ•å°„ç‰©ï¼‰
                if (projectile.type === 'arrow') {
                    if (checkCollision(projectile, player)) {
                        if (player.shields > 0) {
                            player.shields--;
                            showFloatingText('æŠ¤ç›¾ -1', player.x, player.y - 20, '#C0C0C0');
                            gameState.projectiles.splice(i, 1);
                            continue;
                        } else {
                            gameOver();
                            return;
                        }
                    }
                }
                
                // æ£€æŸ¥ä¸æ•Œäººçš„ç¢°æ’ï¼ˆæˆ‘æ–¹æŠ•å°„ç‰©ï¼‰
                let hitEnemy = false;
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    
                    if (checkCollision(projectile, enemy)) {
                        enemy.health -= projectile.damage;
                        showFloatingText(`-${projectile.damage}`, enemy.x, enemy.y, '#FF4500');
                        
                        if (enemy.health <= 0) {
                            gameState.score += enemy.points;
                            showFloatingText(`+${enemy.points}`, enemy.x, enemy.y - 20);
                            gameState.enemies.splice(j, 1);
                            
                            if (Math.random() < 0.2) {
                                spawnShield();
                            }
                        }
                        
                        if (!projectile.pierce) {
                            gameState.projectiles.splice(i, 1);
                            hitEnemy = true;
                            break;
                        }
                    }
                }
                
                if (hitEnemy) continue;
            }
            
            // æ›´æ–°æ•Œäºº
            const currentTime = Date.now();
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // æ°´æ»´æ•Œäººç‰¹æ®Šç§»åŠ¨æ¨¡å¼ï¼šèºæ—‹æ¥è¿‘
                if (enemy.type === 'drop') {
                    enemy.angle += enemy.angleSpeed;
                    const targetX = player.x + Math.cos(enemy.angle) * 100;
                    const targetY = player.y + Math.sin(enemy.angle) * 100;
                    
                    const dx = targetX - enemy.x;
                    const dy = targetY - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                    }
                } else {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                    }
                }

                const distanceToPlayer = Math.sqrt(
                    Math.pow(player.x - enemy.x, 2) + 
                    Math.pow(player.y - enemy.y, 2)
                );
                
                // æ”»å‡»ç©å®¶
                if (distanceToPlayer <= enemy.attackRange && currentTime - enemy.lastAttack >= enemy.attackCooldown) {
                    if (enemy.type === 'archer') {
                        const dx = player.x - enemy.x;
                        const dy = player.y - enemy.y;
                        const angle = Math.atan2(dy, dx);
                        const speedX = Math.cos(angle) * PROJECTILE_SPEED;
                        const speedY = Math.sin(angle) * PROJECTILE_SPEED;
                        
                        gameState.projectiles.push({
                            type: 'arrow',
                            x: enemy.x,
                            y: enemy.y,
                            width: 15,
                            height: 15,
                            speedX: speedX,
                            speedY: speedY,
                            damage: enemy.damage,
                            range: enemy.attackRange,
                            pierce: false,
                            distance: 0,
                            isEnemy: true
                        });
                    } else { // UFOæˆ–æ°´æ»´ç›´æ¥ä¼¤å®³
                        if (player.shields > 0) {
                            player.shields--;
                            showFloatingText('æŠ¤ç›¾ -1', player.x, player.y - 20, '#C0C0C0');
                        } else {
                            gameOver();
                            return;
                        }
                    }
                    
                    enemy.lastAttack = currentTime;
                }
                
                // æ£€æŸ¥ä¸ç©å®¶çš„ç¢°æ’
                if (checkCollision(enemy, player)) {
                    if (player.shields > 0) {
                        player.shields--;
                        showFloatingText('æŠ¤ç›¾ -1', player.x, player.y - 20, '#C0C0C0');
                        enemy.x += (enemy.x - player.x) * 0.5;
                        enemy.y += (enemy.y - player.y) * 0.5;
                    } else {
                        gameOver();
                        return;
                    }
                }
            }
            
            // æ›´æ–°æ”¶é›†å“
            for (let i = gameState.collectibles.length - 1; i >= 0; i--) {
                const collectible = gameState.collectibles[i];
                
                if (checkCollision(collectible, player)) {
                    switch (collectible.type) {
                        case 'sun':
                            if (player.level < 3) {
                                player.level++;
                                showFloatingText('è¿›åŒ–!', player.x, player.y - 30, '#FFD700');
                            } else {
                                if (player.shields < player.maxShields) {
                                    player.shields++;
                                    showFloatingText('æŠ¤ç›¾ +1', player.x, player.y - 30, '#C0C0C0');
                                }
                            }
                            break;
                        case 'star':
                            player.experience += collectible.experience;
                            showFloatingText(`ç»éªŒ +${collectible.experience}`, player.x, player.y - 30, '#C0C0C0');
                            
                            while (player.experience >= player.nextLevelExp) {
                                player.experience -= player.nextLevelExp;
                                player.nextLevelExp = Math.floor(player.nextLevelExp * 1.5);
                                gameState.running = false;
                                showLevelUpOptions();
                                // æ³¨æ„ï¼šå‡çº§æ—¶ä¼šæš‚åœå¾ªç¯ï¼Œæ‰€ä»¥éœ€è¦è·³å‡ºæ”¶é›†å“å¾ªç¯
                                return;
                            }
                            break;
                        case 'shield':
                            if (player.shields < player.maxShields) {
                                player.shields++;
                                showFloatingText('æŠ¤ç›¾ +1', player.x, player.y - 30, '#C0C0C0');
                            }
                            break;
                    }
                    
                    gameState.collectibles.splice(i, 1);
                }
            }
            
            // ç”Ÿæˆæ•Œäºº
            if (currentTime - gameState.lastEnemySpawn > gameState.enemySpawnRate) {
                // æ ¹æ®å½“å‰éš¾åº¦ä¸€æ¬¡ç”Ÿæˆå¤šä¸ªæ•Œäºº
                for (let i = 0; i < gameState.enemiesPerSpawn; i++) {
                    spawnEnemy();
                }
                gameState.lastEnemySpawn = currentTime;
            }
            
            // ç”Ÿæˆå¤ªé˜³
            if (currentTime - gameState.lastSunSpawn > SUN_SPAWN_RATE) {
                spawnSun();
                gameState.lastSunSpawn = currentTime;
            }
            
            // ç”Ÿæˆæ˜Ÿæ˜Ÿ
            if (currentTime - gameState.lastStarSpawn > STAR_SPAWN_RATE) {
                spawnStar();
                gameState.lastStarSpawn = currentTime;
            }
            
            updateUI();
        }
        
        // æ¸²æŸ“æ¸¸æˆ
        function render() {
            ctx.fillStyle = '#1A1A2E';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // ç»˜åˆ¶ç©å®¶
            const player = gameState.player;
            ctx.font = '48px ' + gameFont;
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                textElements.player[player.level], 
                player.x, 
                player.y
            );
            
            // ç»˜åˆ¶æŠ•å°„ç‰©
            for (const projectile of gameState.projectiles) {
                if (projectile.type === 'arrow') {
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.arc(projectile.x, projectile.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    ctx.font = '24px ' + gameFont;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(
                        textElements.weapons[projectile.type] || '?', 
                        projectile.x, 
                        projectile.y
                    );
                }
            }
            
            // ç»˜åˆ¶æ•Œäºº
            for (const enemy of gameState.enemies) {
                ctx.font = '32px ' + gameFont;
                if (enemy.type === 'drop') {
                    ctx.fillStyle = '#00BFFF';
                } else if (enemy.type === 'archer') {
                    ctx.fillStyle = '#FF4500';
                } else {
                    ctx.fillStyle = '#C0C0C0';
                }
                ctx.fillText(
                    textElements.enemies[enemy.type], 
                    enemy.x, 
                    enemy.y
                );
                
                // è¡€æ¡
                const healthBarWidth = enemy.width;
                const healthBarHeight = 5;
                const healthPercentage = enemy.health / enemy.maxHealth;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(
                    enemy.x - healthBarWidth / 2, 
                    enemy.y - enemy.height / 2 - 10, 
                    healthBarWidth, 
                    healthBarHeight
                );
                
                ctx.fillStyle = healthPercentage > 0.5 ? '#32CD32' : healthPercentage > 0.25 ? '#FFD700' : '#FF4500';
                ctx.fillRect(
                    enemy.x - healthBarWidth / 2, 
                    enemy.y - enemy.height / 2 - 10, 
                    healthBarWidth * healthPercentage, 
                    healthBarHeight
                );
            }
            
            // ç»˜åˆ¶æ”¶é›†å“
            for (const collectible of gameState.collectibles) {
                ctx.font = '32px ' + gameFont;
                if (collectible.type === 'sun') {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(textElements.sun, collectible.x, collectible.y);
                } else if (collectible.type === 'star') {
                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillText(textElements.star, collectible.x, collectible.y);
                } else if (collectible.type === 'shield') {
                    ctx.fillStyle = '#00BFFF';
                    ctx.fillText(textElements.shield, collectible.x, collectible.y);
                }
            }
        }
        
        // æ¸¸æˆå¾ªç¯
        let lastTime = 0;
        function gameLoop(timestamp = performance.now()) {
            if (!gameState.running) return;
            
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    gameState.keys.up = true;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    gameState.keys.down = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    gameState.keys.left = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    gameState.keys.right = true;
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    gameState.keys.up = false;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    gameState.keys.down = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    gameState.keys.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    gameState.keys.right = false;
                    break;
            }
        });
        
        // è™šæ‹Ÿæ‘‡æ†
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickBase = document.getElementById('joystickBase');
        const joystickThumb = document.getElementById('joystickThumb');
        
        let joystickActive = false;
        let joystickStartX = 0, joystickStartY = 0;
        let joystickCurrentX = 0, joystickCurrentY = 0;
        const joystickRadius = 60; // åŸºåœ†åŠå¾„
        const thumbRadius = 25; // æ‘‡æ†æ‹‡æŒ‡åŠå¾„
        
        // åˆå§‹åŒ–æ‘‡æ†æ‹‡æŒ‡ä½ç½®
        joystickThumb.style.left = '50%';
        joystickThumb.style.top = '50%';
        joystickThumb.style.transform = 'translate(-50%, -50%)';
        
        joystickThumb.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            const rect = joystickContainer.getBoundingClientRect();
            joystickStartX = rect.left + rect.width / 2;
            joystickStartY = rect.top + rect.height / 2;
            joystickCurrentX = touch.clientX;
            joystickCurrentY = touch.clientY;
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const clientX = touch.clientX;
            const clientY = touch.clientY;
            
            const deltaX = clientX - joystickStartX;
            const deltaY = clientY - joystickStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            let limitedX = deltaX, limitedY = deltaY;
            if (distance > joystickRadius) {
                limitedX = (deltaX / distance) * joystickRadius;
                limitedY = (deltaY / distance) * joystickRadius;
            }
            
            // æ›´æ–°æ‘‡æ†è§†è§‰ä½ç½®
            joystickThumb.style.left = `calc(50% + ${limitedX}px)`;
            joystickThumb.style.top = `calc(50% + ${limitedY}px)`;
            joystickThumb.style.transform = 'translate(-50%, -50%)';
            
            // æ›´æ–°ç§»åŠ¨æ–¹å‘
            gameState.keys.up = false;
            gameState.keys.down = false;
            gameState.keys.left = false;
            gameState.keys.right = false;
            
            const threshold = 15;
            if (Math.abs(limitedX) > threshold) {
                if (limitedX > 0) gameState.keys.right = true;
                else gameState.keys.left = true;
            }
            if (Math.abs(limitedY) > threshold) {
                if (limitedY > 0) gameState.keys.down = true;
                else gameState.keys.up = true;
            }
        });
        
        document.addEventListener('touchend', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            
            joystickActive = false;
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
            
            gameState.keys.up = false;
            gameState.keys.down = false;
            gameState.keys.left = false;
            gameState.keys.right = false;
        });
        
        // æŒ‰é’®äº‹ä»¶
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        
        // åˆå§‹åŒ–å¹¶æ˜¾ç¤ºå¼€å§‹å±å¹•
        initGame();
        startScreen.classList.remove('hidden');
    </script>
</body>
</html>
